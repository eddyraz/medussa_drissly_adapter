defmodule Medusa.RecargaSellAdapter do
  @moduledoc """
  RecargaSell adapter for paid services
  """
  import Record
  import Plug.Conn

  require EEx
  require Logger
  require Medusa.Utils.Xml

  alias Medusa.Utils.Xml

  @attempts_tae 11
  @attempts_services_timeout 17

  def request_get_sku_list() do
    payment_id = UUID.uuid4()
    type = "Servicios"
    initial_log(payment_id, type)

    url = get_url(type)
    body = get_sku_list_template(get_user_name(type), get_password(type))

    result =
    with {:ok, response} <- send_request("GetSkuList", url, body, payment_id, type),
         node when Record.is_record(node, :xmlElement) <- Xml.query('//soap:Envelope/soap:Body/GetSkuListResponse/GetSkuListResult', response) do

      ##Xml.read(response.body)
      xx = Xml.get_text(node)

      {:ok, xml_document} = Xml.read(xx)

      nodes =
        '//root'
        |> Xml.query(xml_document)
        |> Xml.get_child_elements()
        |> Enum.map(fn(child) ->


          #IO.inspect Xml.find_child(child, :"name")
          #IO.inspect Xml.find_child(child, :"sku")

          data = %{}
          |> Map.put(:description, Xml.find_child(child, :"name"))
          |> Map.put(:sku, Xml.find_child(child, :"sku"))
          |> Map.put(:category, "Recarga Tiempo Aire")
          |> Map.put(:third_party_id, 4)
          |> Map.put(:platform, "android|iOS|generic")


          Goliath.Services.create(data)

          #serealize(Xml.xmlElement(child, :name), child)
        end)

    else
      false ->
        {:error, "Unable to request for service, DoT Result"}
      {:error, error} ->
        {:error, error}
    end

    close_log(payment_id, result)
  end

  def request_get_balance() do
    payment_id = UUID.uuid4()
    type = "Servicios"
    initial_log(payment_id, type)

    url = get_url(type)
    body = get_balance_template(get_user_name(type), get_password(type))

    result =
      with {:ok, response} <- send_request("GetBalance", url, body, payment_id, type),
           node when Record.is_record(node, :xmlElement) <- Xml.query('//soap:Envelope/soap:Body/GetBalanceResponse/GetBalanceResult', response) do

        case Xml.get_text(node) do
          "" ->
            {:error, "Unable to get balance"}
          request_id ->
            {:ok, request_id}
        end
      else
        false ->
          {:error, "Unable to request for balance"}
        {:error, error} ->
          {:error, error}
      end

    close_log(payment_id, result)
  end

  def request_get_request_id(payment_id, class) do
    url = get_url(class)
    body = get_request_id_template(get_user_name(class), get_password(class))

    log :info, payment_id, "#{get_time()} Recarga Sell GetTRequestID: #{url}"
    result =
      with {:ok, response} <- send_request("GetTRequestID", url, body, payment_id, class),
           node when Record.is_record(node, :xmlElement) <- Xml.query('//soap:Envelope/soap:Body/GetTRequestIDResponse/GetTRequestIDResult', response) do

        case Xml.get_text(node) do
          "" ->
            log :error, payment_id, "#{get_time()} Recarga Sell transaction_id: #{inspect node}"
            {:error, "Unable to get request_id"}
          request_id ->
            log :info, payment_id, "#{get_time()} Recarga Sell transaction_id: #{request_id}"
            {:ok, request_id}
        end
      else
        false ->
          {:error, "Unable to request for service"}
        {:error, error} ->
          {:error, error}
      end
  end

  def request_dot(sku, reference, amount, payment_id, class, request_id \\ nil) do
    initial_log(payment_id, class)
    url = get_url(class)
    log :info, payment_id, "#{get_time()} Recarga Sell Process Start _____________________________________________"
    log :info, payment_id, "#{get_time()} Recarga Sell Data sku: #{sku} op_account: #{reference} amount: #{amount}"

    result =
      with  {:ok, request_id} = request_get_request_id(payment_id, class),
            body <- request_dot_template(request_id, get_user_name(class), sku, reference, amount),
            {:ok, response} <- send_request("DoT", url, body, payment_id, class),
            node when Record.is_record(node, :xmlElement) <- Xml.query('//soap:Envelope/soap:Body/DoTResponse/DoTResult', response) do

        process_response(node, payment_id, request_id, class)
      else
        false ->
          {:error, "Unable to request for service, DoT Result"}
        {:error, error} ->
          {:error, error}
      end

    close_log(payment_id, result)
  end

  def request_check_transaction(payment_id, request_id, class, attempts \\ 0) do
    url = get_url(class)
    body = check_transaction_template(get_user_name(class), request_id)
    log :info, payment_id, "#{get_time()} Recarga Sell CheckTransaction: #{request_id}"

    with {:ok, response} <- send_request("CheckTransaction", url, body, payment_id, class),
         node when Record.is_record(node, :xmlElement) <- Xml.query('//soap:Envelope/soap:Body/CheckTransactionResponse/CheckTransactionResult', response) do

      process_response(node, payment_id, request_id, class, attempts)
    else
      false ->
        {:error, "Unable to request for service, Check Transaction Result"}
      {:error, error} ->
        {:error, error}
    end
  end

  defp send_request(action, url, body, payment_id, class) do
    log :info, payment_id, "#{get_time()} Recarga Sell URL: #{url} #{action}"

    log = body
    |> String.replace(get_user_name(class), "*****")
    |> String.replace(get_password(class), "*****")

    log :info, payment_id, "#{get_time()} Recarga Sell Request: #{log}"

    response = HTTPotion.post url,
      [body: body,
        headers: get_headers(action),
        timeout: 60_000
        #ibrowse: [proxy_host: '127.0.0.1', proxy_port: 9090]
      ]

    parse_response(payment_id, response)
  end

  defp get_headers(soap_action) do
    [
      "User-Agent": "Miio",
      "Content-Type": "text/xml;charset=UTF-8",
      "Accept-Encoding": "gzip,deflate",
      "SOAPAction": "http://tempuri.org/#{soap_action}"
    ]
  end

  defp parse_response(payment_id, response) do
    case response do
      %HTTPotion.ErrorResponse{} ->
        log :error, payment_id, "#{get_time()} Recarga Sell Response: #{response.message}"
        {:error, response.message}
      _ ->
        case response.status_code do
          200 ->
            log :info, payment_id, "#{get_time()} Recarga Sell Response: #{response.body}"
            Xml.read(response.body)
          400 ->
            log :error, payment_id, "#{get_time()} Recarga Sell Response: #{response.body}"
            {:error, "Recarga Sell: Bad Request"}
          401 ->
            log :error, payment_id, "#{get_time()} Recarga Sell Response: #{response.body}"
          403 ->
            log :error, payment_id, "#{get_time()} Recarga Sell Response: #{response.body}"
            {:error, "Recarga Sell: Access Forbidden"}
          500 ->
            log :error, payment_id, "#{get_time()} Recarga Sell Response: #{response.body}"
            {:error, "Recarga Sell: Internal Server Error"}
          _ ->
            log :error, payment_id, "#{get_time()} Recarga Sell Response: #{response.body}"
            {:ok, document} = Xml.read(response.body)
            {:error, document}
        end
    end
  end

  defp process_response(xmlElement, payment_id, request_id, class, attempts \\ 0) do
    with node when Record.is_record(node, :xmlElement) <- Xml.query('//rcode', xmlElement) do
      rcode = Xml.get_text(node)
      log :info, payment_id, "#{get_time()} Recarga Sell Response transaction_id: #{request_id} rcode: #{rcode} message: #{format_msg(rcode)}"
      case rcode do
        "0" ->
          log :info, payment_id, "#{get_time()} Recarga Sell transaction_id: #{request_id} op_authorization: #{Xml.get_text(Xml.query('//op_authorization', xmlElement))}"
          {:ok, "Transaccioón realizada con éxito."}
        "1" ->
          {:ok, "Transaccioón realizada, Estatus Pendiente"} # validar si se reembolsa o cuado
        "2" ->
          valdiate_attemps(attempts, payment_id, request_id, class)
        "3" ->
          {:error, "La transaccioón no fue realizada."}
        "4" ->
          get_error_description(xmlElement)
        "5" ->
          {:error, "La cuenta proporcionada no es válida."}
        "6" ->
          {:error, "El TRequestID proporcionado no es válido."}
        _ ->
          {:error, "No se puede procesar el pago, por favor llame a soporte técnico"}
      end
    else
      :false ->
        {:error, "Unable to request for service"}
      {:error, error} ->
        {:error, error}
    end
    |> tuple_insert(Xml.to_json(xmlElement))
    #|> Tuple.insert_at(2, Xml.to_json(xmlElement))
  end

  def tuple_insert(tuple, value) do
    case tuple do
      {_type, _msg} ->
        Tuple.insert_at(tuple, 2, value)
      {_type, _msg, _json} ->
        tuple
        |> Tuple.delete_at(2)
        |> Tuple.insert_at(2, value)
    end
  end

  def valdiate_attemps(attempts, payment_id, request_id, class) do
    cond do
      attempts == @attempts_tae && class == "Recarga tae" ->
        {:error, "La transacción está siendo realizada."}
      attempts == @attempts_services_timeout && class == "Servicios" ->
        {:error, "La transacción está siendo realizada."}
      :true ->
        log :info, payment_id, "#{get_time()} Wait 5 second to check transaction #{request_id}, try #{attempts + 1} of #{get_attemps(class)}"
        :timer.sleep(5000)
        request_check_transaction(payment_id, request_id, class, attempts + 1)
    end
  end

  defp log(type, payment_id, msg) do
    case type do
      :debug ->
        Logger.debug msg
      :info ->
        Logger.info msg
      :warn ->
        Logger.warn msg
      :error ->
        Logger.error msg
    end
    IO.binwrite(Application.get_env(:medusa, :"#{payment_id}"), "#{msg}\n")
  end

  defp initial_log(payment_id, class) do
    {:ok, file} = File.open("#{get_path(class)}/#{payment_id}.log", [:append])
    Application.put_env(:medusa, :"#{payment_id}", file)
  end

  defp close_log(payment_id, result) do
    File.close(Application.get_env(:medusa, :"#{payment_id}"))
    result
  end

  defp get_error_description(xmlElement) do
    with node when Record.is_record(node, :xmlElement) <- Xml.query('//rcode_description', xmlElement) do
      {:error, Xml.get_text(node)}
    else
      :false ->
        {:error, "Unable to request for service"}
      {:error, error} ->
        {:error, error}
    end
  end

  defp format_msg(rcode) do
    case rcode do
      "0" ->
        "Transaccioón realizada con éxito."
      "1" ->
        "No se pudo determinar el resultado de la transacción. Esto ocurre cuando hay errores de comunicación entre la plataforma de RecargaSell y el operador o proveedor."
      "2" ->
        "La transacción no fue realizada por (time out)."
      "3" ->
        "La transacción no fue realizada."
      "4" ->
        "La transacción no fue realizada. Un detalle del error se encuentra en TResponse. Rcode_description"
      "5" ->
        "La cuenta proporcionada no es válida."
      "6" ->
        "El TRequestID proporcionado no es válido."
    end
  end

  def get_time() do
    Timex.format!(Timex.now("America/Mexico_City"), "%Y-%m-%d %H:%M:%S.%L", :strftime)
  end

  defp get_url(class) do
    config = Application.get_env(:medusa, get_type(class))
    config[:url]
  end

  defp get_user_name(class) do
    config = Application.get_env(:medusa, get_type(class))
    config[:user_name]
  end

  defp get_path(class) do

    drissly_catalog_of_services: "/catalogo_servicios/",
      drissly_payment_of_services: "/pago_servicios/",
      drissly_tae: "/recarga_tae/",
      drissly_transaction_consult: "/consulta_transaccion/"
    
    config = Application.get_env(:medusa, get_type(class))
    config[:path]
  end

  defp get_password(class) do
    config = Application.get_env(:medusa, get_type(class))
    config[:password]
  end

  def get_type(class) do
    case class do
      "Servicios" ->
        :recarga_sell_sercices
      "Recarga tae" ->
        :recarga_sell_tae
      _ ->
        :nil
    end
  end

  def get_attemps(class) do
    case class do
      "Servicios" ->
        @attempts_services_timeout
      "Recarga tae" ->
        @attempts_tae
      _ ->
        0
    end
  end

  EEx.function_from_file :def, :get_balance_template, "./priv/RecargaSell/get_balance.eex", [:user_name, :password]

  EEx.function_from_file :def, :get_sku_list_template, "./priv/RecargaSell/get_sku_list.eex", [:user_name, :password]

  EEx.function_from_file :def, :get_request_id_template, "./priv/RecargaSell/get_request_id.eex", [:user_name, :password]

  EEx.function_from_file :def, :check_transaction_template, "./priv/RecargaSell/check_transaction.eex", [:user_name, :request_id]

  EEx.function_from_file :def, :request_dot_template, "./priv/RecargaSell/request_dot.eex", [:request_id, :user_name, :sku, :op_account, :amount]

end

# Medusa.RecargaSellAdapter.request_get_sku_list
# Medusa.RecargaSellAdapter.request_get_request_id
# Medusa.RecargaSellAdapter.request_get_balance

# Medusa.RecargaSellAdapter.request_dot("0124002000150A", "IMDM235086381", 150)   Fail
# Medusa.RecargaSellAdapter.request_dot("087002000200A",  "IMDM235086381", 200)   OK

# Medusa.RecargaSellAdapter.request_dot("010100001", "5513546327", 10, UUID.uuid4(), "Recarga tae")



# Medusa.RecargaSellAdapter.request_dot("010200001", "5532038844", 20)
# Medusa.RecargaSellAdapter.request_dot("010300001", "5513546327", 30)
# Medusa.RecargaSellAdapter.request_dot("010500001", "5532038844", 50)
# Medusa.RecargaSellAdapter.request_dot("001000000080A", "5513546327", 80)
# Medusa.RecargaSellAdapter.request_dot("011000001", "5532038844", 100)
# Medusa.RecargaSellAdapter.request_dot("011500001", "5513546327", 150)
# Medusa.RecargaSellAdapter.request_dot("012000001", "5532038844", 200)
# Medusa.RecargaSellAdapter.request_dot("013000001", "5513546327", 300)
# Medusa.RecargaSellAdapter.request_dot("015000001", "5532038844", 500)


# Medusa.RecargaSellAdapter.request_dot("0124002000150A", "IMDM235086381", 150, UUID.uuid4(), "Servicio")

# Medusa.RecargaSellAdapter.request_dot("0124002000300A", "IMDM235086381", 300)

# Medusa.RecargaSellAdapter.request_dot("0124002000500A", "IMDM235086381", 500)

# Medusa.RecargaSellAdapter.request_dot("0128014000150A", "5532038844", 125) #XBOX

# Medusa.RecargaSellAdapter.request_dot("009004000000", "123456789012345678901234567890", 125, UUID.uuid4(), "Servicios") #CFE

# Medusa.RecargaSellAdapter.request_dot("0135014000049A", "5532038844", 49) #CINEPOLIS

# Medusa.RecargaSellAdapter.request_dot("0128014000150A", "5532038844", 239) #CINEPOLIS 5PACK

# Medusa.RecargaSellAdapter.request_dot("0137014000100A", "5532038844", 200) #CINEPOLIS 5PACK

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654321", 100) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238701", 550)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654322", 125) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238702", 550)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654323", 150) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238703", 555)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654324", 175) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238704", 560)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654325", 180) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238705", 565)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654326", 185) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238706", 570)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654327", 190) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238707", 575)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654328", 195) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238708", 580)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654329", 200) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238709", 585)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654330", 205) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238710", 595)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654331", 210) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238711", 600)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654332", 215) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238712", 605)

# Medusa.RecargaSellAdapter.request_dot("009004000000", "098765432109876543210987654333", 220) #CFE

# Medusa.RecargaSellAdapter.request_dot("010003000000", "55561238713", 610)

##  Medusa.RecargaSellAdapter.request_dot("010100001", "5513546327", 10, "Test1")
